<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dawn Galaxy Atlas</title>
<style>
:root{
  --bg:#060A12;
  --panel:#0B1424;
  --stroke:rgba(170,190,220,.14);
  --stroke2:rgba(170,190,220,.10);
  --text:#E7EEF9;
  --muted:rgba(231,238,249,.70);
  --grid:rgba(150,170,210,.22);
  --accent:#7CC3FF;
}
*{box-sizing:border-box}
html,body{height:100%; margin:0; background: radial-gradient(900px 520px at 20% 0%, rgba(30,70,140,.28), rgba(6,10,18,0) 60%), linear-gradient(180deg, #060A12, #050812); color:var(--text); font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;}
#app{height:100%; display:grid; grid-template-columns: 1fr 360px; gap:12px; padding:12px;}
#left{min-width:0; display:flex; flex-direction:column; gap:10px;}
#topbar{display:flex; align-items:center; gap:10px; padding:10px 12px; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border-radius:14px;}
#brand{display:flex; align-items:center; gap:10px; font-weight:800; letter-spacing:.2px;}
#pill{font-size:12px; padding:4px 8px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid var(--stroke2); color:var(--muted);}
.btn{appearance:none; border:1px solid var(--stroke); background:rgba(255,255,255,.04); color:var(--text); padding:7px 10px; border-radius:10px; font-weight:650; font-size:13px; cursor:pointer;}
.btn:hover{background:rgba(255,255,255,.07)}
.btn:active{transform:translateY(1px)}
.btn.toggled{background:rgba(124,195,255,.14); border-color:rgba(124,195,255,.28)}
#searchWrap{margin-left:auto; display:flex; align-items:center; gap:8px; min-width:300px;}
#search{width:100%; padding:9px 12px; border-radius:999px; border:1px solid var(--stroke); background:rgba(10,18,34,.70); color:var(--text); outline:none;}
#search::placeholder{color:rgba(231,238,249,.45)}
#plotWrap{flex:1; min-height:420px; border:1px solid var(--stroke); border-radius:16px; overflow:hidden; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,0)); position:relative;}
#plot{width:100%; height:100%; background:var(--bg);}
#plotMask{position:absolute; inset:0; pointer-events:auto;}
#toast{position:absolute; left:14px; bottom:14px; padding:10px 12px; border-radius:12px; background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.12); color:rgba(231,238,249,.92); font-size:12px; display:none;}
#right{display:flex; flex-direction:column; gap:12px; min-width:0;}
.panel{border:1px solid var(--stroke); border-radius:16px; background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); padding:12px;}
.panel h3{margin:0 0 8px 0; font-size:14px; letter-spacing:.2px; color:rgba(231,238,249,.88)}
.small{font-size:12px; color:var(--muted)}
.legendRow{display:flex; align-items:center; gap:10px; padding:7px 8px; border-top:1px solid var(--stroke2);}
.legendRow:first-of-type{border-top:0}
.dot{width:10px; height:10px; border-radius:999px; background:rgba(255,255,255,.8)}
.diamond{width:10px; height:10px; transform:rotate(45deg); background:rgba(255,255,255,.85)}
.moon{width:6px; height:6px; border-radius:999px; background:rgba(255,255,255,.8)}
.halo{width:12px; height:12px; border-radius:999px; border:2px solid rgba(124,195,255,.85); background:transparent}
.cap{width:12px; height:12px; border-radius:999px; border:2px solid rgba(124,195,255,.85); background:transparent; position:relative}
.cap:after{content:""; position:absolute; inset:2px; border:2px solid rgba(124,195,255,.55); border-radius:999px}
.conf{width:12px; height:12px; border-radius:999px; border:2px dashed rgba(255,92,122,.95); background:transparent}
#detailsHeader{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px;}
#preview{width:86px; height:86px; border-radius:14px; border:1px solid var(--stroke); background:radial-gradient(circle at 35% 30%, rgba(255,255,255,.18), rgba(0,0,0,0) 60%), rgba(10,18,34,.60);}
#detailsGrid{display:grid; grid-template-columns: 1fr 1fr; gap:6px 10px; font-size:12px;}
.k{color:rgba(231,238,249,.62)}
.v{color:rgba(231,238,249,.92); font-weight:650; text-align:right; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}
.hr{height:1px; background:var(--stroke2); margin:10px 0}
#findList{max-height:240px; overflow:auto; margin-top:8px; border-radius:12px; border:1px solid var(--stroke2);}
.findItem{padding:9px 10px; border-top:1px solid var(--stroke2); cursor:pointer;}
.findItem:first-child{border-top:0}
.findItem:hover{background:rgba(255,255,255,.05)}
.findName{font-weight:750; font-size:12px}
.findMeta{font-size:11px; color:var(--muted)}
@media (max-width: 980px) {
  #app{grid-template-columns: 1fr;}
}
</style>
</head>
<body>
<div id="app">
  <div id="left">
    <div id="topbar">
      <div id="brand">
        <div style="width:18px;height:18px;border-radius:6px;background:linear-gradient(135deg,#7CC3FF,#C27CFF); opacity:.9"></div>
        <div>Dawn Galaxy Atlas</div>
        <div id="pill">Loading data...</div>
      </div>

      <button id="btnOrbits" class="btn toggled" title="Show orbit rings for the selected system">Orbits: Selected</button>
      <button id="btnGlow" class="btn" title="Add a soft glow layer to stars">Star glow</button>
      <button id="btnGrid" class="btn toggled" title="Toggle the grid">Grid</button>
      <button id="btnReset" class="btn" title="Reset view">Reset</button>

      <div id="searchWrap">
        <input id="search" type="text" placeholder="Search name, system, classification..."/>
      </div>
    </div>

    <div id="plotWrap">
      <div id="plot"></div>
      <div id="plotMask" title="Tap empty space to clear selection"></div>
      <div id="toast"></div>
    </div>
  </div>

  <div id="right">
    <div class="panel">
      <h3>Micro legend</h3>
      <div class="legendRow"><div class="dot"></div><div class="small" style="flex:1">Star</div></div>
      <div class="legendRow"><div class="diamond"></div><div class="small" style="flex:1">Planet</div></div>
      <div class="legendRow"><div class="moon"></div><div class="small" style="flex:1">Moon (if present)</div></div>
      <div class="legendRow"><div class="halo"></div><div class="small" style="flex:1">Homeworld (halo, if tagged)</div></div>
      <div class="legendRow"><div class="cap"></div><div class="small" style="flex:1">Capital (double halo, if tagged)</div></div>
      <div class="legendRow"><div class="conf"></div><div class="small" style="flex:1">Conflict / restricted (dashed ring, if tagged)</div></div>
      <div class="small" style="margin-top:8px">Colors are unique per object.</div>
    </div>

    <div class="panel">
      <div id="detailsHeader">
        <h3 style="margin:0">Details</h3>
        <div class="small">Tap empty space for Unknown.</div>
      </div>

      <div style="display:flex; gap:10px; align-items:flex-start">
        <canvas id="preview" width="86" height="86"></canvas>
        <div style="flex:1">
          <div class="small" id="detailsTitle" style="font-weight:750; font-size:13px; color:rgba(231,238,249,.92)">Unknown</div>
          <div class="small" id="detailsSub" style="margin-top:2px">Unexplored sector</div>
        </div>
      </div>

      <div class="hr"></div>
      <div id="detailsGrid"></div>
    </div>

    <div class="panel">
      <h3>Find</h3>
      <div class="small">Use the top search. Tap a result to jump.</div>
      <div id="findList"></div>
    </div>
  </div>
</div>

<script src="./plotly-2.4.1.min.js"></script>
<script>
(() => {
  "use strict";

  const CSV_URL = "./dawn_atlas.csv";

  const BG = "#060A12";
  const GRID_ON = "rgba(150,170,210,0.22)";
  const GRID_OFF = "rgba(150,170,210,0.00)";
  const AXIS = "rgba(231,238,249,0.18)";
  const ORBIT_SCALE = 2.2;
  const ORBIT_LINE = "rgba(124,195,255,0.32)";

  const pill = document.getElementById("pill");
  const plotEl = document.getElementById("plot");
  const maskEl = document.getElementById("plotMask");
  const toastEl = document.getElementById("toast");

  const btnOrbits = document.getElementById("btnOrbits");
  const btnGlow = document.getElementById("btnGlow");
  const btnGrid = document.getElementById("btnGrid");
  const btnReset = document.getElementById("btnReset");

  const search = document.getElementById("search");
  const findList = document.getElementById("findList");

  const detailsTitle = document.getElementById("detailsTitle");
  const detailsSub = document.getElementById("detailsSub");
  const detailsGrid = document.getElementById("detailsGrid");
  const preview = document.getElementById("preview");
  const pctx = preview.getContext("2d", { willReadFrequently: true });

  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const safe = (v) => (v === undefined || v === null || String(v).trim() === "" || String(v).trim() === "-") ? "Unknown" : String(v);
  const num = (v) => {
    const x = Number(v);
    return Number.isFinite(x) ? x : null;
  };

  function col(row, key) {
    if (!row) return "";
    if (Object.prototype.hasOwnProperty.call(row, key)) return row[key];
    const want = String(key).trim().toLowerCase();
    for (const k in row) {
      if (String(k).trim().toLowerCase() === want) return row[k];
    }
    return "";
  }

  function hash32(str) {
    let h = 0x811c9dc5;
    for (let i=0;i<str.length;i++) {
      h ^= str.charCodeAt(i);
      h = (h + ((h<<1) + (h<<4) + (h<<7) + (h<<8) + (h<<24))) >>> 0;
    }
    return h >>> 0;
  }

  function hueColor(key) {
    const h = hash32(key) % 360;
    return `hsl(${h}, 78%, 62%)`;
  }

  function toast(msg) {
    toastEl.textContent = msg;
    toastEl.style.display = "block";
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(() => toastEl.style.display = "none", 2300);
  }

  const previewState = {
    key: null,
    texture: null,
    phase: 0,
    speed: 0.00006,
    type: "planet"
  };
  let previewAnimId = null;
  let previewLast = 0;

  function makeRng(seed) {
    let s = seed >>> 0;
    return () => {
      s = (s * 1664525 + 1013904223) >>> 0;
      return s / 4294967295;
    };
  }

  function makePlanetTexture(key, type) {
    const seed = hash32(String(key));
    const isStar = String(type || "").toLowerCase().includes("star");
    const tw = 256;
    const th = 128;
    const canvas = document.createElement("canvas");
    canvas.width = tw;
    canvas.height = th;
    const ctx = canvas.getContext("2d");
    const rng = makeRng(seed ^ 0x9e3779b9);
    const baseHue = seed % 360;
    const bandCount = 2 + (seed % 3);

    for (let y=0;y<th;y++) {
      const t = y / (th - 1);
      const band = Math.sin(t * Math.PI * 2 * bandCount) * 0.5 + 0.5;
      const hue = (baseHue + band * 30 + (isStar ? 20 : 0)) % 360;
      const sat = isStar ? 75 : 55;
      const light = isStar ? 55 + band * 25 : 30 + band * 25;
      ctx.fillStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
      ctx.fillRect(0, y, tw, 1);
    }

    ctx.globalAlpha = isStar ? 0.25 : 0.18;
    for (let i=0;i<1200;i++) {
      const x = Math.floor(rng() * tw);
      const y = Math.floor(rng() * th);
      const w = 1 + Math.floor(rng() * 3);
      const h = 1 + Math.floor(rng() * 2);
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.fillRect(x, y, w, h);
    }
    ctx.globalAlpha = 0.2;
    for (let i=0;i<300;i++) {
      const x = Math.floor(rng() * tw);
      const y = Math.floor(rng() * th);
      const w = 2 + Math.floor(rng() * 6);
      const h = 1 + Math.floor(rng() * 3);
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(x, y, w, h);
    }
    ctx.globalAlpha = 1;

    return canvas;
  }

  function setPreviewTarget(key, type) {
    const k = String(key || "Unknown");
    if (previewState.key !== k || !previewState.texture) {
      previewState.key = k;
      previewState.texture = makePlanetTexture(k, type);
      previewState.phase = 0;
    }
    previewState.type = String(type || "");
    previewState.speed = previewState.type.toLowerCase().includes("star") ? 0.00002 : 0.00006;
    if (!previewAnimId) {
      previewLast = 0;
      previewAnimId = requestAnimationFrame(animatePreview);
    }
  }

  function drawPlanetFrame() {
    const w = preview.width;
    const h = preview.height;
    const r = Math.min(w, h) / 2 - 4;
    const cx = w / 2;
    const cy = h / 2;
    pctx.clearRect(0, 0, w, h);

    const tex = previewState.texture;
    if (!tex) return;

    pctx.save();
    pctx.beginPath();
    pctx.arc(cx, cy, r, 0, Math.PI * 2);
    pctx.clip();

    const scale = (r * 2) / tex.height;
    const drawW = tex.width * scale;
    const drawH = tex.height * scale;
    const offset = (previewState.phase * tex.width) % tex.width;
    const startX = cx - r - offset * scale;
    const startY = cy - r;

    pctx.drawImage(tex, startX, startY, drawW, drawH);
    pctx.drawImage(tex, startX + drawW, startY, drawW, drawH);
    pctx.restore();

    const lightX = cx - r * 0.35;
    const lightY = cy - r * 0.35;
    const glow = pctx.createRadialGradient(lightX, lightY, r * 0.15, cx, cy, r);
    glow.addColorStop(0, "rgba(255,255,255,0.55)");
    glow.addColorStop(0.55, "rgba(255,255,255,0.0)");
    glow.addColorStop(1, "rgba(0,0,0,0.55)");
    pctx.fillStyle = glow;
    pctx.beginPath();
    pctx.arc(cx, cy, r, 0, Math.PI * 2);
    pctx.fill();

    const terminator = pctx.createLinearGradient(cx - r, cy, cx + r, cy);
    terminator.addColorStop(0, "rgba(0,0,0,0.45)");
    terminator.addColorStop(0.6, "rgba(0,0,0,0.0)");
    terminator.addColorStop(1, "rgba(0,0,0,0.2)");
    pctx.fillStyle = terminator;
    pctx.beginPath();
    pctx.arc(cx, cy, r, 0, Math.PI * 2);
    pctx.fill();

    pctx.strokeStyle = "rgba(124,195,255,0.28)";
    pctx.lineWidth = 1.4;
    pctx.beginPath();
    pctx.arc(cx, cy, r + 0.5, 0, Math.PI * 2);
    pctx.stroke();
  }

  function animatePreview(ts) {
    if (!previewState.texture) {
      previewAnimId = requestAnimationFrame(animatePreview);
      return;
    }
    if (!previewLast) previewLast = ts;
    const dt = Math.min(40, ts - previewLast);
    previewLast = ts;
    previewState.phase = (previewState.phase + dt * previewState.speed) % 1;
    drawPlanetFrame();
    previewAnimId = requestAnimationFrame(animatePreview);
  }

  function renderDetails(row) {
    if (!row) {
      detailsTitle.textContent = "Unknown";
      detailsSub.textContent = "Unexplored sector";
      detailsGrid.innerHTML = "";
      setPreviewTarget("Unknown", "Unknown");
      return;
    }
    const name = safe(col(row, "Name"));
    const system = safe(col(row, "System Name"));
    const type = safe(col(row, "Type"));
    const classification = safe(col(row, "Classification"));
    const x = num(col(row, "X"));
    const y = num(col(row, "Y"));
    const grid = safe(col(row, "Grid Position"));
    const quadrant = safe(col(row, "Quadrant_16"));
    const systemType = safe(col(row, "System Type"));
    const habitability = safe(col(row, "Habitability"));

    detailsTitle.textContent = name;
    detailsSub.textContent = system;

    const coords = (Number.isFinite(x) && Number.isFinite(y)) ? `${x}, ${y}` : "Unknown";
    const fields = [
      ["Coordinates", coords],
      ["Grid", grid],
      ["Quadrant", quadrant],
      ["Type", type],
      ["System", systemType],
      ["Classification", classification],
      ["Habitability", habitability]
    ];

    detailsGrid.innerHTML = fields.map(([k,v]) =>
      `<div class="k">${k}</div><div class="v">${v}</div>`
    ).join("");

    setPreviewTarget(name + "|" + system, type);
  }

  function parseCSV(text) {
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    for (let i=0;i<text.length;i++) {
      const c = text[i];
      const n = text[i+1];

      if (inQuotes) {
        if (c === '"' && n === '"') {
          cell += '"';
          i++;
        } else if (c === '"') {
          inQuotes = false;
        } else {
          cell += c;
        }
      } else {
        if (c === '"') {
          inQuotes = true;
        } else if (c === ',') {
          row.push(cell);
          cell = "";
        } else if (c === '\n' || c === '\r') {
          if (c === '\r' && n === '\n') i++;
          row.push(cell);
          cell = "";
          if (row.length === 1 && row[0].trim() === "") {
            row = [];
            continue;
          }
          rows.push(row);
          row = [];
        } else {
          cell += c;
        }
      }
    }
    if (cell.length || row.length) {
      row.push(cell);
      rows.push(row);
    }
    if (!rows.length) return [];
    const header = rows[0].map(h => h.trim());
    const out = [];
    for (let r=1;r<rows.length;r++) {
      const o = {};
      const rr = rows[r];
      for (let c=0;c<header.length;c++) {
        o[header[c]] = rr[c] !== undefined ? rr[c] : "";
      }
      out.push(o);
    }
    return out;
  }

  function computeBounds(rows) {
    let xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity;
    for (const r of rows) {
      const x = Number.isFinite(r.__x) ? r.__x : num(col(r, "X"));
      const y = Number.isFinite(r.__y) ? r.__y : num(col(r, "Y"));
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      if (x < xmin) xmin = x;
      if (x > xmax) xmax = x;
      if (y < ymin) ymin = y;
      if (y > ymax) ymax = y;
    }
    if (!Number.isFinite(xmin)) return null;
    return { xmin, xmax, ymin, ymax };
  }

  function buildSystemAnchors(rows) {
    const anchors = new Map();
    for (const r of rows) {
      const sys = safe(col(r, "System Name"));
      const type = safe(col(r, "Type")).toLowerCase();
      const x = num(col(r, "X"));
      const y = num(col(r, "Y"));
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
      if (!type.includes("star")) continue;
      const rank = num(col(r, "Star Size Rank"));
      const rankVal = Number.isFinite(rank) ? rank : -Infinity;
      const existing = anchors.get(sys);
      if (!existing || rankVal > existing.rank) {
        anchors.set(sys, { x, y, rank: rankVal });
      }
    }
    for (const r of rows) {
      const sys = safe(col(r, "System Name"));
      if (anchors.has(sys)) continue;
      const x = num(col(r, "X"));
      const y = num(col(r, "Y"));
      if (Number.isFinite(x) && Number.isFinite(y)) {
        anchors.set(sys, { x, y, rank: -Infinity });
      }
    }
    return anchors;
  }

  function calcOrbitRadius(row) {
    const au = num(col(row, "Distance from Star (AU)"));
    const orbitNum = num(col(row, "Orbit Number"));
    const base = Number.isFinite(au) ? au : (Number.isFinite(orbitNum) ? orbitNum : null);
    if (!Number.isFinite(base)) return null;
    return Math.max(0.5, base * ORBIT_SCALE);
  }

  function orbitAngle(row, system) {
    const name = safe(col(row, "Name"));
    const orbitNum = num(col(row, "Orbit Number")) || 0;
    const seed = hash32(`${system}|${name}`);
    return (seed % 360) * (Math.PI / 180) + orbitNum * 0.45;
  }

  function applyOrbitLayout(rows) {
    SYSTEM_ANCHORS = buildSystemAnchors(rows);
    SYSTEM_ORBITS.clear();

    for (const r of rows) {
      const baseX = num(col(r, "X"));
      const baseY = num(col(r, "Y"));
      const sys = safe(col(r, "System Name"));
      const anchor = SYSTEM_ANCHORS.get(sys);
      const ax = anchor ? anchor.x : baseX;
      const ay = anchor ? anchor.y : baseY;
      const type = safe(col(r, "Type")).toLowerCase();

      r.__orbit = null;
      if (type.includes("planet")) {
        const radius = calcOrbitRadius(r);
        if (Number.isFinite(radius) && Number.isFinite(ax) && Number.isFinite(ay)) {
          const ang = orbitAngle(r, sys);
          r.__x = ax + Math.cos(ang) * radius;
          r.__y = ay + Math.sin(ang) * radius;
          r.__orbit = radius;
          if (!SYSTEM_ORBITS.has(sys)) SYSTEM_ORBITS.set(sys, new Set());
          SYSTEM_ORBITS.get(sys).add(radius);
        } else {
          r.__x = baseX;
          r.__y = baseY;
        }
      } else {
        r.__x = baseX;
        r.__y = baseY;
      }
    }
  }

  function buildOrbitShapes(system) {
    const anchor = SYSTEM_ANCHORS.get(system);
    if (!anchor) return [];
    const set = SYSTEM_ORBITS.get(system);
    if (!set || !set.size) return [];
    const radii = Array.from(set).sort((a, b) => a - b);
    return radii.map((r) => ({
      type: "circle",
      xref: "x",
      yref: "y",
      x0: anchor.x - r,
      x1: anchor.x + r,
      y0: anchor.y - r,
      y1: anchor.y + r,
      line: { color: ORBIT_LINE, width: 1, dash: "dot" },
      fillcolor: "rgba(0,0,0,0)",
      layer: "below"
    }));
  }

  function updateOrbitRings(row) {
    if (orbitsMode !== "selected" || !row) {
      Plotly.relayout(plotEl, { shapes: [] });
      return;
    }
    const system = safe(col(row, "System Name"));
    Plotly.relayout(plotEl, { shapes: buildOrbitShapes(system) });
  }

  async function fetchWithTimeout(url, timeoutMs) {
    if (typeof AbortController === "undefined") {
      return fetch(url, { cache: "no-cache" });
    }
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      return await fetch(url, { cache: "no-cache", signal: controller.signal });
    } finally {
      clearTimeout(timer);
    }
  }

  async function loadCsvText() {
    try {
      const res = await fetchWithTimeout(CSV_URL, 3000);
      if (!res.ok) throw new Error(`CSV load failed (${res.status})`);
      return await res.text();
    } catch (err) {
      throw new Error("CSV load failed. Serve this folder over HTTP (python -m http.server) and open http://localhost:8000/dawn-atlas/.");
    }
  }

  let ALL = [];
  let BY_ID = new Map();
  let SYSTEM_ANCHORS = new Map();
  let SYSTEM_ORBITS = new Map();
  let bounds = null;
  let selectedId = null;
  let isGridOn = true;
  let isGlowOn = false;
  let orbitsMode = "selected";
  let clickedPoint = false;

  function buildTraces() {
    const xs = [];
    const ys = [];
    const colors = [];
    const sizes = [];
    const symbols = [];
    const ids = [];

    for (let i=0;i<ALL.length;i++) {
      const r = ALL[i];
      const x = Number.isFinite(r.__x) ? r.__x : num(col(r, "X"));
      const y = Number.isFinite(r.__y) ? r.__y : num(col(r, "Y"));
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

      const name = safe(col(r, "Name"));
      const system = safe(col(r, "System Name"));
      const type = safe(col(r, "Type"));

      const key = `${system}|${name}|${type}`;
      const color = hueColor(key);
      const typeLower = type.toLowerCase();

      xs.push(x);
      ys.push(y);
      colors.push(color);
      ids.push(r.__id);

      if (typeLower.includes("moon")) {
        sizes.push(6);
        symbols.push("circle-open");
      } else if (typeLower.includes("planet")) {
        sizes.push(9);
        symbols.push("diamond");
      } else {
        sizes.push(12);
        symbols.push("circle");
      }

    }

    const glowTrace = {
      type: "scattergl",
      mode: "markers",
      x: xs,
      y: ys,
      hoverinfo: "skip",
      visible: isGlowOn,
      marker: {
        size: sizes.map(s => s * 2.2),
        color: colors,
        opacity: 0.18
      }
    };

    const mainTrace = {
      type: "scattergl",
      mode: "markers",
      x: xs,
      y: ys,
      customdata: ids,
      marker: {
        size: sizes,
        color: colors,
        symbol: symbols,
        line: { color: "rgba(255,255,255,0.35)", width: 1 }
      },
      hovertemplate: "%{text}<extra></extra>",
      text: ids.map((id) => {
        const r = BY_ID.get(id);
        const name = safe(col(r, "Name"));
        const system = safe(col(r, "System Name"));
        const type = safe(col(r, "Type"));
        const cls = safe(col(r, "Classification"));
        return `${name} | ${type} | ${system} | ${cls}`;
      })
    };

    const selectTrace = {
      type: "scattergl",
      mode: "markers",
      x: [],
      y: [],
      hoverinfo: "skip",
      marker: {
        size: 18,
        color: "rgba(0,0,0,0)",
        symbol: "circle-open",
        line: { color: "rgba(124,195,255,0.9)", width: 2 }
      }
    };

    return [glowTrace, mainTrace, selectTrace];
  }

  function baseLayout() {
    const pad = bounds ? Math.max((bounds.xmax - bounds.xmin) * 0.05, 6) : 10;
    const xRange = bounds ? [bounds.xmin - pad, bounds.xmax + pad] : [0, 100];
    const yRange = bounds ? [bounds.ymin - pad, bounds.ymax + pad] : [0, 100];

    return {
      paper_bgcolor: BG,
      plot_bgcolor: BG,
      margin: { l: 40, r: 20, t: 20, b: 40 },
      xaxis: {
        showgrid: isGridOn,
        gridcolor: isGridOn ? GRID_ON : GRID_OFF,
        zeroline: false,
        color: AXIS,
        range: xRange,
        fixedrange: false
      },
      yaxis: {
        showgrid: isGridOn,
        gridcolor: isGridOn ? GRID_ON : GRID_OFF,
        zeroline: false,
        color: AXIS,
        range: yRange,
        fixedrange: false,
        scaleanchor: "x",
        scaleratio: 1
      },
      hovermode: "closest",
      showlegend: false
    };
  }

  function zoomTo(row) {
    if (!row || !bounds) return;
    const x = Number.isFinite(row.__x) ? row.__x : num(col(row, "X"));
    const y = Number.isFinite(row.__y) ? row.__y : num(col(row, "Y"));
    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
    const span = Math.max((bounds.xmax - bounds.xmin), (bounds.ymax - bounds.ymin)) * 0.12;
    Plotly.relayout(plotEl, {
      "xaxis.range": [x - span, x + span],
      "yaxis.range": [y - span, y + span]
    });
  }

  function setSelectedById(id) {
    selectedId = id;
    if (!id) {
      Plotly.restyle(plotEl, { x: [[]], y: [[]] }, [2]);
      renderDetails(null);
      updateOrbitRings(null);
      return;
    }
    const row = BY_ID.get(id);
    if (!row) {
      renderDetails(null);
      updateOrbitRings(null);
      return;
    }
    const x = Number.isFinite(row.__x) ? row.__x : num(col(row, "X"));
    const y = Number.isFinite(row.__y) ? row.__y : num(col(row, "Y"));
    if (Number.isFinite(x) && Number.isFinite(y)) {
      Plotly.restyle(plotEl, { x: [[x]], y: [[y]] }, [2]);
    }
    renderDetails(row);
    updateOrbitRings(row);
  }

  function updateFindList(q) {
    const query = (q || "").trim().toLowerCase();
    findList.innerHTML = "";
    if (!query) return;

    const rows = [];
    for (const r of ALL) {
      const nm = safe(col(r, "Name")).toLowerCase();
      const sys = safe(col(r, "System Name")).toLowerCase();
      const cls = safe(col(r, "Classification")).toLowerCase();
      const typ = safe(col(r, "Type")).toLowerCase();
      if (nm.includes(query) || sys.includes(query) || cls.includes(query) || typ.includes(query)) {
        rows.push(r);
      }
      if (rows.length >= 40) break;
    }

    for (const r of rows) {
      const item = document.createElement("div");
      item.className = "findItem";
      item.innerHTML = `<div class="findName">${safe(col(r, "Name"))}</div>
                        <div class="findMeta">${safe(col(r, "Type"))} | ${safe(col(r, "System Name"))} | ${safe(col(r, "Classification"))}</div>`;
      item.addEventListener("click", () => {
        setSelectedById(r.__id);
        zoomTo(r);
      });
      findList.appendChild(item);
    }
  }

  function hookEvents() {
    if (maskEl) maskEl.style.pointerEvents = "none";

    plotEl.on("plotly_click", (ev) => {
      if (!ev.points || !ev.points.length) return;
      clickedPoint = true;
      const id = ev.points[0].customdata;
      setSelectedById(id);
    });

    plotEl.addEventListener("click", () => {
      setTimeout(() => {
        if (clickedPoint) {
          clickedPoint = false;
          return;
        }
        setSelectedById(null);
      }, 0);
    });

    btnGrid.addEventListener("click", () => {
      isGridOn = !isGridOn;
      btnGrid.classList.toggle("toggled", isGridOn);
      Plotly.relayout(plotEl, {
        "xaxis.showgrid": isGridOn,
        "yaxis.showgrid": isGridOn,
        "xaxis.gridcolor": isGridOn ? GRID_ON : GRID_OFF,
        "yaxis.gridcolor": isGridOn ? GRID_ON : GRID_OFF
      });
    });

    btnGlow.addEventListener("click", () => {
      isGlowOn = !isGlowOn;
      btnGlow.classList.toggle("toggled", isGlowOn);
      Plotly.restyle(plotEl, { visible: isGlowOn }, [0]);
    });

    btnOrbits.addEventListener("click", () => {
      if (orbitsMode === "selected") {
        orbitsMode = "off";
        btnOrbits.classList.remove("toggled");
        btnOrbits.textContent = "Orbits: Off";
      } else {
        orbitsMode = "selected";
        btnOrbits.classList.add("toggled");
        btnOrbits.textContent = "Orbits: Selected";
      }
      updateOrbitRings(selectedId ? BY_ID.get(selectedId) : null);
    });

    btnReset.addEventListener("click", () => {
      Plotly.relayout(plotEl, {
        "xaxis.autorange": true,
        "yaxis.autorange": true
      });
    });

    search.addEventListener("input", () => updateFindList(search.value));
  }

  async function init() {
    try {
      pill.textContent = "Loading data...";
      renderDetails(null);

      if (!window.Plotly) throw new Error("Plotly failed to load");

      const text = await loadCsvText();
      ALL = parseCSV(text);
      if (!ALL.length) throw new Error("No rows found in CSV");
      applyOrbitLayout(ALL);
      bounds = computeBounds(ALL);

      BY_ID.clear();
      for (let i=0;i<ALL.length;i++) {
        const r = ALL[i];
        r.__id = `${safe(col(r, "System Name"))}|${safe(col(r, "Name"))}|${safe(col(r, "Type"))}|${i}`;
        BY_ID.set(r.__id, r);
      }

      const traces = buildTraces();
      await Plotly.newPlot(plotEl, traces, baseLayout(), {
        displayModeBar: false,
        responsive: true,
        scrollZoom: true
      });

      pill.textContent = "Ready";
      hookEvents();
      setSelectedById(null);
    } catch (err) {
      pill.textContent = "Error";
      toast(`Map error: ${err.message || err}`);
      console.error(err);
    }
  }

  init();
})();
</script>
</body>
</html>
